# =============================================================================
# Logstash Pipeline  — Honeypot Log Parsing + GeoIP Enrichment
# Handles: Cowrie (SSH/Telnet), Dionaea (multi-protocol), Flask (HTTP)
# =============================================================================

# ---------------------------------------------------------------------------
# INPUT — tail all honeypot log files
# ---------------------------------------------------------------------------
input {

  # Cowrie SSH/Telnet honeypot — JSON log lines
  file {
    path          => "/var/log/honeypots/cowrie/cowrie.json*"
    codec         => "json"
    type          => "cowrie"
    sincedb_path  => "/usr/share/logstash/data/sincedb_cowrie"
    start_position => "beginning"
  }

  # Dionaea multi-protocol honeypot — plain text log
  file {
    path          => "/var/log/honeypots/dionaea/*.log"
    codec         => "plain"
    type          => "dionaea"
    sincedb_path  => "/usr/share/logstash/data/sincedb_dionaea"
    start_position => "beginning"
  }

  # Flask HTTP honeypot — plain text log
  file {
    path          => "/var/log/honeypots/flask/*.log"
    codec         => "plain"
    type          => "flask"
    sincedb_path  => "/usr/share/logstash/data/sincedb_flask"
    start_position => "beginning"
  }
}

# ---------------------------------------------------------------------------
# FILTER — normalise, enrich and tag each event
# ---------------------------------------------------------------------------
filter {

  # ── Cowrie (SSH / Telnet honeypot) ──────────────────────────────────────
  if [type] == "cowrie" {

    # Tag the honeypot type and map Cowrie eventids to readable strings.
    # Note: src_ip, username, password, input are already decoded from JSON.
    mutate {
      add_field => { "honeypot_type" => "cowrie-ssh" }
    }

    if [eventid] == "cowrie.login.failed"           { mutate { add_field => { "event_type" => "login_failed"   } } }
    if [eventid] == "cowrie.login.success"          { mutate { add_field => { "event_type" => "login_success"  } } }
    if [eventid] == "cowrie.command.input"          { mutate { add_field => { "event_type" => "command_exec"   } } }
    if [eventid] == "cowrie.session.file_download"  { mutate { add_field => { "event_type" => "file_download"  } } }

    # Parse Cowrie's ISO-8601 timestamp into @timestamp so the timeline is accurate.
    # Cowrie timestamps look like: 2024-01-15T12:34:56.789000Z
    if [timestamp] {
      date {
        match   => ["timestamp", "ISO8601"]
        target  => "@timestamp"
        timezone => "UTC"
      }
    }

    # GeoIP from source IP
    if [src_ip] {
      geoip {
        source  => "src_ip"
        target  => "geoip"
        add_tag => ["geoip_enriched"]
      }
    }
  }

  # ── Dionaea (multi-protocol honeypot) ────────────────────────────────────
  if [type] == "dionaea" {

    # Example Dionaea log line:
    # 2024-01-15 12:34:56,789 dionaea.capture - INFO - connection from 1.2.3.4
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:dionaea_message}"
      }
      overwrite      => ["timestamp"]
      tag_on_failure => ["_grokparsefailure_dionaea_ts"]
    }

    mutate {
      add_field => { "honeypot_type" => "dionaea"       }
      add_field => { "event_type"    => "dionaea_event" }
    }

    # Try to extract attacker IP from the message body
    grok {
      match          => { "message" => "(?:connection from|src[= ])%{IP:src_ip}" }
      tag_on_failure => []
    }

    if [src_ip] {
      geoip {
        source  => "src_ip"
        target  => "geoip"
        add_tag => ["geoip_enriched"]
      }
    }

    date {
      match    => ["timestamp", "yyyy-MM-dd HH:mm:ss,SSS", "ISO8601"]
      target   => "@timestamp"
      timezone => "UTC"
    }
  }

  # ── Flask HTTP honeypot ──────────────────────────────────────────────────
  if [type] == "flask" {

    # Log format produced by the Flask honeypot:
    # 2024-01-15 12:34:56,789 - Request from 1.2.3.4: GET http://target/path
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} - Request from %{IP:src_ip}: %{WORD:http_method} %{URI:request_url}"
      }
      tag_on_failure => ["_grokparsefailure_flask"]
    }

    mutate {
      add_field => { "honeypot_type" => "flask-http"   }
      add_field => { "event_type"    => "http_request" }
    }

    if [src_ip] {
      geoip {
        source  => "src_ip"
        target  => "geoip"
        add_tag => ["geoip_enriched"]
      }
    }

    date {
      match    => ["timestamp", "yyyy-MM-dd HH:mm:ss,SSS", "ISO8601"]
      target   => "@timestamp"
      timezone => "UTC"
    }
  }

  # ── Common enrichment for all types ────────────────────────────────────
  mutate {
    remove_field => ["host", "log", "ecs", "agent", "input_type", "offset"]
  }

  # Tag RFC-1918 / loopback IPs — no GeoIP lookup possible for these
  if [src_ip] =~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.)/ {
    mutate { add_tag => ["private_ip"] }
  }
}

# ---------------------------------------------------------------------------
# OUTPUT — write to date-partitioned Elasticsearch indices
# ---------------------------------------------------------------------------
output {

  if [type] == "cowrie" {
    elasticsearch {
      hosts       => ["${ELASTICSEARCH_HOSTS}"]
      index       => "honeypot-cowrie-%{+YYYY.MM.dd}"
      action      => "index"
      ilm_enabled => false
    }
  }

  else if [type] == "dionaea" {
    elasticsearch {
      hosts       => ["${ELASTICSEARCH_HOSTS}"]
      index       => "honeypot-dionaea-%{+YYYY.MM.dd}"
      action      => "index"
      ilm_enabled => false
    }
  }

  else if [type] == "flask" {
    elasticsearch {
      hosts       => ["${ELASTICSEARCH_HOSTS}"]
      index       => "honeypot-flask-%{+YYYY.MM.dd}"
      action      => "index"
      ilm_enabled => false
    }
  }

  else {
    elasticsearch {
      hosts       => ["${ELASTICSEARCH_HOSTS}"]
      index       => "honeypot-unknown-%{+YYYY.MM.dd}"
      action      => "index"
      ilm_enabled => false
    }
  }
}
