# =============================================================================
# Logstash Pipeline  — Honeypot Log Parsing + GeoIP Enrichment
# Handles: Cowrie (SSH/Telnet), Dionaea (multi-protocol), Flask (HTTP)
# =============================================================================

# ---------------------------------------------------------------------------
# INPUT — tail all honeypot log files
# ---------------------------------------------------------------------------
input {

  # Cowrie SSH/Telnet honeypot — JSON log lines
  file {
    path  => "/var/log/honeypots/cowrie/cowrie.json*"
    codec => "json"
    type  => "cowrie"
    sincedb_path => "/usr/share/logstash/data/sincedb_cowrie"
    start_position => "beginning"
  }

  # Dionaea multi-protocol honeypot — plain text log
  file {
    path  => "/var/log/honeypots/dionaea/*.log"
    codec => "plain"
    type  => "dionaea"
    sincedb_path => "/usr/share/logstash/data/sincedb_dionaea"
    start_position => "beginning"
  }

  # Flask HTTP honeypot — plain text log
  file {
    path  => "/var/log/honeypots/flask/*.log"
    codec => "plain"
    type  => "flask"
    sincedb_path => "/usr/share/logstash/data/sincedb_flask"
    start_position => "beginning"
  }
}

# ---------------------------------------------------------------------------
# FILTER — normalise, enrich and tag each event
# ---------------------------------------------------------------------------
filter {

  # ── Cowrie ──────────────────────────────────────────────────────────────
  if [type] == "cowrie" {

    # Rename Cowrie's src_ip field (already JSON-decoded by codec)
    mutate {
      rename       => { "src_ip"  => "src_ip" }
      rename       => { "username" => "username" }
      rename       => { "password" => "password" }
      rename       => { "input"    => "input" }
      add_field    => { "honeypot_type" => "cowrie-ssh" }
    }

    # Map Cowrie event IDs to readable types
    if [eventid] == "cowrie.login.failed"  { mutate { add_field => { "event_type" => "login_failed"  } } }
    if [eventid] == "cowrie.login.success" { mutate { add_field => { "event_type" => "login_success" } } }
    if [eventid] == "cowrie.command.input" { mutate { add_field => { "event_type" => "command_exec"  } } }
    if [eventid] == "cowrie.session.file_download" { mutate { add_field => { "event_type" => "file_download" } } }

    # GeoIP from source IP
    if [src_ip] {
      geoip {
        source        => "src_ip"
        target        => "geoip"
        add_tag       => ["geoip_enriched"]
      }
    }
  }

  # ── Dionaea ─────────────────────────────────────────────────────────────
  if [type] == "dionaea" {

    # Example Dionaea log line:
    # 2024-01-15 12:34:56,789 dionaea.capture - INFO - ...
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:dionaea_message}"
      }
      overwrite => ["timestamp"]
    }

    mutate {
      add_field => { "honeypot_type" => "dionaea" }
      add_field => { "event_type"    => "dionaea_event" }
    }

    # Try to extract attacker IP from message
    grok {
      match   => { "message" => "(?:connection from|src[= ])%{IP:src_ip}" }
      tag_on_failure => []
    }

    if [src_ip] {
      geoip {
        source  => "src_ip"
        target  => "geoip"
        add_tag => ["geoip_enriched"]
      }
    }

    date {
      match    => ["timestamp", "yyyy-MM-dd HH:mm:ss,SSS"]
      target   => "@timestamp"
      timezone => "UTC"
    }
  }

  # ── Flask HTTP honeypot ──────────────────────────────────────────────────
  if [type] == "flask" {

    # Log format: 2024-01-15 12:34:56,789 - Request from 1.2.3.4: GET http://...
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} - Request from %{IP:src_ip}: %{WORD:http_method} %{URI:request_url}"
      }
      tag_on_failure => ["_grokparsefailure_flask"]
    }

    mutate {
      add_field => { "honeypot_type" => "flask-http" }
      add_field => { "event_type"    => "http_request" }
    }

    if [src_ip] {
      geoip {
        source  => "src_ip"
        target  => "geoip"
        add_tag => ["geoip_enriched"]
      }
    }

    date {
      match    => ["timestamp", "yyyy-MM-dd HH:mm:ss,SSS"]
      target   => "@timestamp"
      timezone => "UTC"
    }
  }

  # ── Common enrichment for all types ────────────────────────────────────

  # Remove internal Logstash fields
  mutate {
    remove_field => ["host", "log", "ecs", "agent", "input_type", "offset"]
  }

  # Tag private / RFC-1918 IPs so they can be filtered in dashboards
  if [src_ip] =~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/ {
    mutate { add_tag => ["private_ip"] }
  }
}

# ---------------------------------------------------------------------------
# OUTPUT — write to Elasticsearch
# ---------------------------------------------------------------------------
output {

  if [type] == "cowrie" {
    elasticsearch {
      hosts         => ["${ELASTICSEARCH_HOSTS}"]
      index         => "honeypot-cowrie-%{+YYYY.MM.dd}"
      action        => "index"
      ilm_enabled   => false
    }
  }

  else if [type] == "dionaea" {
    elasticsearch {
      hosts         => ["${ELASTICSEARCH_HOSTS}"]
      index         => "honeypot-dionaea-%{+YYYY.MM.dd}"
      action        => "index"
      ilm_enabled   => false
    }
  }

  else if [type] == "flask" {
    elasticsearch {
      hosts         => ["${ELASTICSEARCH_HOSTS}"]
      index         => "honeypot-flask-%{+YYYY.MM.dd}"
      action        => "index"
      ilm_enabled   => false
    }
  }

  else {
    elasticsearch {
      hosts         => ["${ELASTICSEARCH_HOSTS}"]
      index         => "honeypot-unknown-%{+YYYY.MM.dd}"
      action        => "index"
      ilm_enabled   => false
    }
  }
}
